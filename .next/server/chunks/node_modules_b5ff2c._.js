module.exports = {

"[project]/node_modules/delayed-stream/lib/delayed_stream.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var Stream = __turbopack_require__("[externals]/stream [external] (stream, cjs)").Stream;
var util = __turbopack_require__("[externals]/util [external] (util, cjs)");
module.exports = DelayedStream;
function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);
DelayedStream.create = function(source, options) {
    var delayedStream = new this();
    options = options || {};
    for(var option in options){
        delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
    };
    source.on('error', function() {});
    if (delayedStream.pauseStream) {
        source.pause();
    }
    return delayedStream;
};
Object.defineProperty(DelayedStream.prototype, 'readable', {
    configurable: true,
    enumerable: true,
    get: function() {
        return this.source.readable;
    }
});
DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
};
DelayedStream.prototype.resume = function() {
    if (!this._released) {
        this.release();
    }
    this.source.resume();
};
DelayedStream.prototype.pause = function() {
    this.source.pause();
};
DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach((function(args) {
        this.emit.apply(this, args);
    }).bind(this));
    this._bufferedEvents = [];
};
DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
};
DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
        this.emit.apply(this, args);
        return;
    }
    if (args[0] === 'data') {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
};
DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
        return;
    }
    if (this.dataSize <= this.maxDataSize) {
        return;
    }
    this._maxDataSizeExceeded = true;
    var message = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
    this.emit('error', new Error(message));
};
}}),
"[project]/node_modules/combined-stream/lib/combined_stream.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var util = __turbopack_require__("[externals]/util [external] (util, cjs)");
var Stream = __turbopack_require__("[externals]/stream [external] (stream, cjs)").Stream;
var DelayedStream = __turbopack_require__("[project]/node_modules/delayed-stream/lib/delayed_stream.js [app-route] (ecmascript)");
module.exports = CombinedStream;
function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
}
util.inherits(CombinedStream, Stream);
CombinedStream.create = function(options) {
    var combinedStream = new this();
    options = options || {};
    for(var option in options){
        combinedStream[option] = options[option];
    }
    return combinedStream;
};
CombinedStream.isStreamLike = function(stream) {
    return typeof stream !== 'function' && typeof stream !== 'string' && typeof stream !== 'boolean' && typeof stream !== 'number' && !Buffer.isBuffer(stream);
};
CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
            var newStream = DelayedStream.create(stream, {
                maxDataSize: Infinity,
                pauseStream: this.pauseStreams
            });
            stream.on('data', this._checkDataSize.bind(this));
            stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
            stream.pause();
        }
    }
    this._streams.push(stream);
    return this;
};
CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
};
CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
        this._pendingNext = true;
        return; // defer call
    }
    this._insideLoop = true;
    try {
        do {
            this._pendingNext = false;
            this._realGetNext();
        }while (this._pendingNext)
    } finally{
        this._insideLoop = false;
    }
};
CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == 'undefined') {
        this.end();
        return;
    }
    if (typeof stream !== 'function') {
        this._pipeNext(stream);
        return;
    }
    var getStream = stream;
    getStream((function(stream) {
        var isStreamLike = CombinedStream.isStreamLike(stream);
        if (isStreamLike) {
            stream.on('data', this._checkDataSize.bind(this));
            this._handleErrors(stream);
        }
        this._pipeNext(stream);
    }).bind(this));
};
CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
        stream.on('end', this._getNext.bind(this));
        stream.pipe(this, {
            end: false
        });
        return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
};
CombinedStream.prototype._handleErrors = function(stream) {
    var self = this;
    stream.on('error', function(err) {
        self._emitError(err);
    });
};
CombinedStream.prototype.write = function(data) {
    this.emit('data', data);
};
CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
        return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == 'function') this._currentStream.pause();
    this.emit('pause');
};
CombinedStream.prototype.resume = function() {
    if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == 'function') this._currentStream.resume();
    this.emit('resume');
};
CombinedStream.prototype.end = function() {
    this._reset();
    this.emit('end');
};
CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit('close');
};
CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
};
CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
        return;
    }
    var message = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
    this._emitError(new Error(message));
};
CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self = this;
    this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
            return;
        }
        self.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
    }
};
CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit('error', err);
};
}}),
"[project]/node_modules/mime-types/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 * @private
 */ var db = __turbopack_require__("[project]/node_modules/mime-db/index.js [app-route] (ecmascript)");
var extname = __turbopack_require__("[externals]/path [external] (path, cjs)").extname;
/**
 * Module variables.
 * @private
 */ var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
var TEXT_TYPE_REGEXP = /^text\//i;
/**
 * Module exports.
 * @public
 */ exports.charset = charset;
exports.charsets = {
    lookup: charset
};
exports.contentType = contentType;
exports.extension = extension;
exports.extensions = Object.create(null);
exports.lookup = lookup;
exports.types = Object.create(null);
// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types);
/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function charset(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
        return mime.charset;
    }
    // default text/* to utf-8
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return 'UTF-8';
    }
    return false;
}
/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */ function contentType(str) {
    // TODO: should this even be in this module?
    if (!str || typeof str !== 'string') {
        return false;
    }
    var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;
    if (!mime) {
        return false;
    }
    // TODO: use content-type or other module
    if (mime.indexOf('charset') === -1) {
        var charset = exports.charset(mime);
        if (charset) mime += '; charset=' + charset.toLowerCase();
    }
    return mime;
}
/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function extension(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    // get extensions
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
        return false;
    }
    return exts[0];
}
/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */ function lookup(path) {
    if (!path || typeof path !== 'string') {
        return false;
    }
    // get the extension ("ext" or ".ext" or full path)
    var extension = extname('x.' + path).toLowerCase().substr(1);
    if (!extension) {
        return false;
    }
    return exports.types[extension] || false;
}
/**
 * Populate the extensions and types maps.
 * @private
 */ function populateMaps(extensions, types) {
    // source preference (least -> most)
    var preference = [
        'nginx',
        'apache',
        undefined,
        'iana'
    ];
    Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
            return;
        }
        // mime -> extensions
        extensions[type] = exts;
        // extension -> mime
        for(var i = 0; i < exts.length; i++){
            var extension = exts[i];
            if (types[extension]) {
                var from = preference.indexOf(db[types[extension]].source);
                var to = preference.indexOf(mime.source);
                if (types[extension] !== 'application/octet-stream' && (from > to || from === to && types[extension].substr(0, 12) === 'application/')) {
                    continue;
                }
            }
            // set the extension -> mime
            types[extension] = type;
        }
    });
}
}}),
"[project]/node_modules/asynckit/lib/defer.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
module.exports = defer;
/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */ function defer(fn) {
    var nextTick = typeof setImmediate == 'function' ? setImmediate : typeof process == 'object' && typeof process.nextTick == 'function' ? process.nextTick : null;
    if (nextTick) {
        nextTick(fn);
    } else {
        setTimeout(fn, 0);
    }
}
}}),
"[project]/node_modules/asynckit/lib/async.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var defer = __turbopack_require__("[project]/node_modules/asynckit/lib/defer.js [app-route] (ecmascript)");
// API
module.exports = async;
/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */ function async(callback) {
    var isAsync = false;
    // check if async happened
    defer(function() {
        isAsync = true;
    });
    return function async_callback(err, result) {
        if (isAsync) {
            callback(err, result);
        } else {
            defer(function nextTick_callback() {
                callback(err, result);
            });
        }
    };
}
}}),
"[project]/node_modules/asynckit/lib/abort.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
// API
module.exports = abort;
/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */ function abort(state) {
    Object.keys(state.jobs).forEach(clean.bind(state));
    // reset leftover jobs
    state.jobs = {};
}
/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */ function clean(key) {
    if (typeof this.jobs[key] == 'function') {
        this.jobs[key]();
    }
}
}}),
"[project]/node_modules/asynckit/lib/iterate.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var async = __turbopack_require__("[project]/node_modules/asynckit/lib/async.js [app-route] (ecmascript)"), abort = __turbopack_require__("[project]/node_modules/asynckit/lib/abort.js [app-route] (ecmascript)");
// API
module.exports = iterate;
/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */ function iterate(list, iterator, state, callback) {
    // store current index
    var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;
    state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        // don't repeat yourself
        // skip secondary callbacks
        if (!(key in state.jobs)) {
            return;
        }
        // clean up jobs
        delete state.jobs[key];
        if (error) {
            // don't process rest of the results
            // stop still active jobs
            // and reset the list
            abort(state);
        } else {
            state.results[key] = output;
        }
        // return salvaged results
        callback(error, state.results);
    });
}
/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */ function runJob(iterator, key, item, callback) {
    var aborter;
    // allow shortcut if iterator expects only two arguments
    if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
    } else {
        aborter = iterator(item, key, async(callback));
    }
    return aborter;
}
}}),
"[project]/node_modules/asynckit/lib/state.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
// API
module.exports = state;
/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */ function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
        // sort array keys based on it's values
        // sort object's keys just on own merit
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
            return sortMethod(list[a], list[b]);
        });
    }
    return initState;
}
}}),
"[project]/node_modules/asynckit/lib/terminator.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var abort = __turbopack_require__("[project]/node_modules/asynckit/lib/abort.js [app-route] (ecmascript)"), async = __turbopack_require__("[project]/node_modules/asynckit/lib/async.js [app-route] (ecmascript)");
// API
module.exports = terminator;
/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */ function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
        return;
    }
    // fast forward iteration index
    this.index = this.size;
    // abort jobs
    abort(this);
    // send back results we have so far
    async(callback)(null, this.results);
}
}}),
"[project]/node_modules/asynckit/parallel.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var iterate = __turbopack_require__("[project]/node_modules/asynckit/lib/iterate.js [app-route] (ecmascript)"), initState = __turbopack_require__("[project]/node_modules/asynckit/lib/state.js [app-route] (ecmascript)"), terminator = __turbopack_require__("[project]/node_modules/asynckit/lib/terminator.js [app-route] (ecmascript)");
// Public API
module.exports = parallel;
/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */ function parallel(list, iterator, callback) {
    var state = initState(list);
    while(state.index < (state['keyedList'] || list).length){
        iterate(list, iterator, state, function(error, result) {
            if (error) {
                callback(error, result);
                return;
            }
            // looks like it's the last one
            if (Object.keys(state.jobs).length === 0) {
                callback(null, state.results);
                return;
            }
        });
        state.index++;
    }
    return terminator.bind(state, callback);
}
}}),
"[project]/node_modules/asynckit/serialOrdered.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var iterate = __turbopack_require__("[project]/node_modules/asynckit/lib/iterate.js [app-route] (ecmascript)"), initState = __turbopack_require__("[project]/node_modules/asynckit/lib/state.js [app-route] (ecmascript)"), terminator = __turbopack_require__("[project]/node_modules/asynckit/lib/terminator.js [app-route] (ecmascript)");
// Public API
module.exports = serialOrdered;
// sorting helpers
module.exports.ascending = ascending;
module.exports.descending = descending;
/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */ function serialOrdered(list, iterator, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
            callback(error, result);
            return;
        }
        state.index++;
        // are we there yet?
        if (state.index < (state['keyedList'] || list).length) {
            iterate(list, iterator, state, iteratorHandler);
            return;
        }
        // done here
        callback(null, state.results);
    });
    return terminator.bind(state, callback);
}
/*
 * -- Sort methods
 */ /**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */ function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}
/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */ function descending(a, b) {
    return -1 * ascending(a, b);
}
}}),
"[project]/node_modules/asynckit/serial.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var serialOrdered = __turbopack_require__("[project]/node_modules/asynckit/serialOrdered.js [app-route] (ecmascript)");
// Public API
module.exports = serial;
/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */ function serial(list, iterator, callback) {
    return serialOrdered(list, iterator, null, callback);
}
}}),
"[project]/node_modules/asynckit/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
module.exports = {
    parallel: __turbopack_require__("[project]/node_modules/asynckit/parallel.js [app-route] (ecmascript)"),
    serial: __turbopack_require__("[project]/node_modules/asynckit/serial.js [app-route] (ecmascript)"),
    serialOrdered: __turbopack_require__("[project]/node_modules/asynckit/serialOrdered.js [app-route] (ecmascript)")
};
}}),
"[project]/node_modules/form-data/lib/populate.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
// populates missing values
module.exports = function(dst, src) {
    Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
    });
    return dst;
};
}}),
"[project]/node_modules/form-data/lib/form_data.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var CombinedStream = __turbopack_require__("[project]/node_modules/combined-stream/lib/combined_stream.js [app-route] (ecmascript)");
var util = __turbopack_require__("[externals]/util [external] (util, cjs)");
var path = __turbopack_require__("[externals]/path [external] (path, cjs)");
var http = __turbopack_require__("[externals]/http [external] (http, cjs)");
var https = __turbopack_require__("[externals]/https [external] (https, cjs)");
var parseUrl = __turbopack_require__("[externals]/url [external] (url, cjs)").parse;
var fs = __turbopack_require__("[externals]/fs [external] (fs, cjs)");
var Stream = __turbopack_require__("[externals]/stream [external] (stream, cjs)").Stream;
var mime = __turbopack_require__("[project]/node_modules/mime-types/index.js [app-route] (ecmascript)");
var asynckit = __turbopack_require__("[project]/node_modules/asynckit/index.js [app-route] (ecmascript)");
var populate = __turbopack_require__("[project]/node_modules/form-data/lib/populate.js [app-route] (ecmascript)");
// Public API
module.exports = FormData;
// make it a Stream
util.inherits(FormData, CombinedStream);
/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
 */ function FormData(options) {
    if (!(this instanceof FormData)) {
        return new FormData(options);
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {};
    for(var option in options){
        this[option] = options[option];
    }
}
FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';
FormData.prototype.append = function(field, value, options) {
    options = options || {};
    // allow filename as single option
    if (typeof options == 'string') {
        options = {
            filename: options
        };
    }
    var append = CombinedStream.prototype.append.bind(this);
    // all that streamy business can't handle numbers
    if (typeof value == 'number') {
        value = '' + value;
    }
    // https://github.com/felixge/node-form-data/issues/38
    if (Array.isArray(value)) {
        // Please convert your array into string
        // the way web server expects it
        this._error(new Error('Arrays are not supported.'));
        return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    // pass along options.knownLength
    this._trackLength(header, value, options);
};
FormData.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    // used w/ getLengthSync(), when length is known.
    // e.g. for streaming directly from a remote server,
    // w/ a known file a size, and not wanting to wait for
    // incoming file to finish to get its size.
    if (options.knownLength != null) {
        valueLength += +options.knownLength;
    } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
    } else if (typeof value === 'string') {
        valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    // @check why add CRLF? does this account for custom/multiple CRLFs?
    this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
    // empty or either doesn't have path or not an http response or not a stream
    if (!value || !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) && !(value instanceof Stream)) {
        return;
    }
    // no need to bother with the length
    if (!options.knownLength) {
        this._valuesToMeasure.push(value);
    }
};
FormData.prototype._lengthRetriever = function(value, callback) {
    if (value.hasOwnProperty('fd')) {
        // take read range into a account
        // `end` = Infinity –> read file till the end
        //
        // TODO: Looks like there is bug in Node fs.createReadStream
        // it doesn't respect `end` options without `start` options
        // Fix it when node fixes it.
        // https://github.com/joyent/node/issues/7819
        if (value.end != undefined && value.end != Infinity && value.start != undefined) {
            // when end specified
            // no need to calculate range
            // inclusive, starts with 0
            callback(null, value.end + 1 - (value.start ? value.start : 0));
        // not that fast snoopy
        } else {
            // still need to fetch file size from fs
            fs.stat(value.path, function(err, stat) {
                var fileSize;
                if (err) {
                    callback(err);
                    return;
                }
                // update final size based on the range options
                fileSize = stat.size - (value.start ? value.start : 0);
                callback(null, fileSize);
            });
        }
    // or http response
    } else if (value.hasOwnProperty('httpVersion')) {
        callback(null, +value.headers['content-length']);
    // or request stream http://github.com/mikeal/request
    } else if (value.hasOwnProperty('httpModule')) {
        // wait till response come back
        value.on('response', function(response) {
            value.pause();
            callback(null, +response.headers['content-length']);
        });
        value.resume();
    // something else
    } else {
        callback('Unknown stream');
    }
};
FormData.prototype._multiPartHeader = function(field, value, options) {
    // custom header specified (as string)?
    // it becomes responsible for boundary
    // (e.g. to handle extra CRLFs on .NET servers)
    if (typeof options.header == 'string') {
        return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = '';
    var headers = {
        // add custom disposition as third element or keep it two elements if not
        'Content-Disposition': [
            'form-data',
            'name="' + field + '"'
        ].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        'Content-Type': [].concat(contentType || [])
    };
    // allow custom headers.
    if (typeof options.header == 'object') {
        populate(headers, options.header);
    }
    var header;
    for(var prop in headers){
        if (!headers.hasOwnProperty(prop)) continue;
        header = headers[prop];
        // skip nullish headers.
        if (header == null) {
            continue;
        }
        // convert all headers to arrays.
        if (!Array.isArray(header)) {
            header = [
                header
            ];
        }
        // add non-empty headers.
        if (header.length) {
            contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
        }
    }
    return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};
FormData.prototype._getContentDisposition = function(value, options) {
    var filename, contentDisposition;
    if (typeof options.filepath === 'string') {
        // custom filepath for relative paths
        filename = path.normalize(options.filepath).replace(/\\/g, '/');
    } else if (options.filename || value.name || value.path) {
        // custom filename take precedence
        // formidable and the browser add a name property
        // fs- and request- streams have path property
        filename = path.basename(options.filename || value.name || value.path);
    } else if (value.readable && value.hasOwnProperty('httpVersion')) {
        // or try http response
        filename = path.basename(value.client._httpMessage.path || '');
    }
    if (filename) {
        contentDisposition = 'filename="' + filename + '"';
    }
    return contentDisposition;
};
FormData.prototype._getContentType = function(value, options) {
    // use custom content-type above all
    var contentType = options.contentType;
    // or try `name` from formidable, browser
    if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
    }
    // or try `path` from fs-, request- streams
    if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
    }
    // or if it's http-reponse
    if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
        contentType = value.headers['content-type'];
    }
    // or guess it from the filepath or filename
    if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
    }
    // fallback to the default content type if `value` is not simple value
    if (!contentType && typeof value == 'object') {
        contentType = FormData.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
};
FormData.prototype._multiPartFooter = function() {
    return (function(next) {
        var footer = FormData.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
            footer += this._lastBoundary();
        }
        next(footer);
    }).bind(this);
};
FormData.prototype._lastBoundary = function() {
    return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};
FormData.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
        'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
    };
    for(header in userHeaders){
        if (userHeaders.hasOwnProperty(header)) {
            formHeaders[header.toLowerCase()] = userHeaders[header];
        }
    }
    return formHeaders;
};
FormData.prototype.setBoundary = function(boundary) {
    this._boundary = boundary;
};
FormData.prototype.getBoundary = function() {
    if (!this._boundary) {
        this._generateBoundary();
    }
    return this._boundary;
};
FormData.prototype.getBuffer = function() {
    var dataBuffer = new Buffer.alloc(0);
    var boundary = this.getBoundary();
    // Create the form content. Add Line breaks to the end of data.
    for(var i = 0, len = this._streams.length; i < len; i++){
        if (typeof this._streams[i] !== 'function') {
            // Add content to the buffer.
            if (Buffer.isBuffer(this._streams[i])) {
                dataBuffer = Buffer.concat([
                    dataBuffer,
                    this._streams[i]
                ]);
            } else {
                dataBuffer = Buffer.concat([
                    dataBuffer,
                    Buffer.from(this._streams[i])
                ]);
            }
            // Add break after content.
            if (typeof this._streams[i] !== 'string' || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
                dataBuffer = Buffer.concat([
                    dataBuffer,
                    Buffer.from(FormData.LINE_BREAK)
                ]);
            }
        }
    }
    // Add the footer and return the Buffer object.
    return Buffer.concat([
        dataBuffer,
        Buffer.from(this._lastBoundary())
    ]);
};
FormData.prototype._generateBoundary = function() {
    // This generates a 50 character boundary similar to those used by Firefox.
    // They are optimized for boyer-moore parsing.
    var boundary = '--------------------------';
    for(var i = 0; i < 24; i++){
        boundary += Math.floor(Math.random() * 10).toString(16);
    }
    this._boundary = boundary;
};
// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    // Don't get confused, there are 3 "internal" streams for each keyval pair
    // so it basically checks if there is any value added to the form
    if (this._streams.length) {
        knownLength += this._lastBoundary().length;
    }
    // https://github.com/form-data/form-data/issues/40
    if (!this.hasKnownLength()) {
        // Some async length retrievers are present
        // therefore synchronous length calculation is false.
        // Please use getLength(callback) to get proper length
        this._error(new Error('Cannot calculate proper length in synchronous way.'));
    }
    return knownLength;
};
// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
        hasKnownLength = false;
    }
    return hasKnownLength;
};
FormData.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
        knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
    }
    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
            cb(err);
            return;
        }
        values.forEach(function(length) {
            knownLength += length;
        });
        cb(null, knownLength);
    });
};
FormData.prototype.submit = function(params, cb) {
    var request, options, defaults = {
        method: 'post'
    };
    // parse provided url if it's string
    // or treat it as options object
    if (typeof params == 'string') {
        params = parseUrl(params);
        options = populate({
            port: params.port,
            path: params.pathname,
            host: params.hostname,
            protocol: params.protocol
        }, defaults);
    // use custom params
    } else {
        options = populate(params, defaults);
        // if no port provided use default one
        if (!options.port) {
            options.port = options.protocol == 'https:' ? 443 : 80;
        }
    }
    // put that good code in getHeaders to some use
    options.headers = this.getHeaders(params.headers);
    // https if specified, fallback to http in any other case
    if (options.protocol == 'https:') {
        request = https.request(options);
    } else {
        request = http.request(options);
    }
    // get content length and fire away
    this.getLength((function(err, length) {
        if (err && err !== 'Unknown stream') {
            this._error(err);
            return;
        }
        // add content length
        if (length) {
            request.setHeader('Content-Length', length);
        }
        this.pipe(request);
        if (cb) {
            var onResponse;
            var callback = function(error, responce) {
                request.removeListener('error', callback);
                request.removeListener('response', onResponse);
                return cb.call(this, error, responce);
            };
            onResponse = callback.bind(this, null);
            request.on('error', callback);
            request.on('response', onResponse);
        }
    }).bind(this));
    return request;
};
FormData.prototype._error = function(err) {
    if (!this.error) {
        this.error = err;
        this.pause();
        this.emit('error', err);
    }
};
FormData.prototype.toString = function() {
    return '[object FormData]';
};
}}),
"[project]/node_modules/proxy-from-env/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
var parseUrl = __turbopack_require__("[externals]/url [external] (url, cjs)").parse;
var DEFAULT_PORTS = {
    ftp: 21,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
};
var stringEndsWith = String.prototype.endsWith || function(s) {
    return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
};
/**
 * @param {string|object} url - The URL, or the result from url.parse.
 * @return {string} The URL of the proxy that should handle the request to the
 *  given URL. If no proxy is set, this will be an empty string.
 */ function getProxyForUrl(url) {
    var parsedUrl = typeof url === 'string' ? parseUrl(url) : url || {};
    var proto = parsedUrl.protocol;
    var hostname = parsedUrl.host;
    var port = parsedUrl.port;
    if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {
        return ''; // Don't proxy URLs without a valid scheme or host.
    }
    proto = proto.split(':', 1)[0];
    // Stripping ports in this way instead of using parsedUrl.hostname to make
    // sure that the brackets around IPv6 addresses are kept.
    hostname = hostname.replace(/:\d*$/, '');
    port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
    if (!shouldProxy(hostname, port)) {
        return ''; // Don't proxy URLs that match NO_PROXY.
    }
    var proxy = getEnv('npm_config_' + proto + '_proxy') || getEnv(proto + '_proxy') || getEnv('npm_config_proxy') || getEnv('all_proxy');
    if (proxy && proxy.indexOf('://') === -1) {
        // Missing scheme in proxy, default to the requested URL's scheme.
        proxy = proto + '://' + proxy;
    }
    return proxy;
}
/**
 * Determines whether a given URL should be proxied.
 *
 * @param {string} hostname - The host name of the URL.
 * @param {number} port - The effective port of the URL.
 * @returns {boolean} Whether the given URL should be proxied.
 * @private
 */ function shouldProxy(hostname, port) {
    var NO_PROXY = (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();
    if (!NO_PROXY) {
        return true; // Always proxy if NO_PROXY is not set.
    }
    if (NO_PROXY === '*') {
        return false; // Never proxy if wildcard is set.
    }
    return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
            return true; // Skip zero-length hosts.
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
            return true; // Skip if ports don't match.
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
            // No wildcards, so stop proxying if there is an exact match.
            return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === '*') {
            // Remove leading wildcard.
            parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        // Stop proxying if the hostname ends with the no_proxy host.
        return !stringEndsWith.call(hostname, parsedProxyHostname);
    });
}
/**
 * Get the value for an environment variable.
 *
 * @param {string} key - The name of the environment variable.
 * @return {string} The value of the environment variable.
 * @private
 */ function getEnv(key) {
    return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';
}
exports.getProxyForUrl = getProxyForUrl;
}}),
"[project]/node_modules/ms/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
        return parse(val);
    } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) {
        return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch(type){
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
        return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}
}}),
"[project]/node_modules/debug/src/common.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = __turbopack_require__("[project]/node_modules/ms/index.js [app-route] (ecmascript)");
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) {
                return;
            }
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== 'string') {
                // Anything else let's inspect with %O
                args.unshift('%O');
            }
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === '%%') {
                    return '%';
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === 'function') {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, 'enabled', {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) {
                    return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === 'function') {
            createDebug.init(debug);
        }
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(' ', ',').split(',').filter(Boolean);
        for (const ns of split){
            if (ns[0] === '-') {
                createDebug.skips.push(ns.slice(1));
            } else {
                createDebug.names.push(ns);
            }
        }
    }
    /**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */ function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while(searchIndex < search.length){
            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
                // Match character or proceed with wildcard
                if (template[templateIndex] === '*') {
                    starIndex = templateIndex;
                    matchIndex = searchIndex;
                    templateIndex++; // Skip the '*'
                } else {
                    searchIndex++;
                    templateIndex++;
                }
            } else if (starIndex !== -1) {
                // Backtrack to the last '*' and try to match more characters
                templateIndex = starIndex + 1;
                matchIndex++;
                searchIndex = matchIndex;
            } else {
                return false; // No match
            }
        }
        // Handle trailing '*' in template
        while(templateIndex < template.length && template[templateIndex] === '*'){
            templateIndex++;
        }
        return templateIndex === template.length;
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names,
            ...createDebug.skips.map((namespace)=>'-' + namespace)
        ].join(',');
        createDebug.enable('');
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        for (const skip of createDebug.skips){
            if (matchesTemplate(name, skip)) {
                return false;
            }
        }
        for (const ns of createDebug.names){
            if (matchesTemplate(name, ns)) {
                return true;
            }
        }
        return false;
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) {
            return val.stack || val.message;
        }
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;
}}),
"[project]/node_modules/debug/src/node.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * Module dependencies.
 */ const tty = __turbopack_require__("[externals]/tty [external] (tty, cjs)");
const util = __turbopack_require__("[externals]/util [external] (util, cjs)");
/**
 * This is the Node.js implementation of `debug()`.
 */ exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(()=>{}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
/**
 * Colors.
 */ exports.colors = [
    6,
    2,
    3,
    4,
    5,
    1
];
try {
    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
    // eslint-disable-next-line import/no-extraneous-dependencies
    const supportsColor = __turbopack_require__("[project]/node_modules/supports-color/index.js [app-route] (ecmascript)");
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
        ];
    }
} catch (error) {
// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}
/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{
    return /^debug_/i.test(key);
}).reduce((obj, key)=>{
    // Camel-case
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{
        return k.toUpperCase();
    });
    // Coerce string value into JS value
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
    } else if (val === 'null') {
        val = null;
    } else {
        val = Number(val);
    }
    obj[prop] = val;
    return obj;
}, {});
/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */ function useColors() {
    return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}
/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    const { namespace: name, useColors } = this;
    if (useColors) {
        const c = this.color;
        const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
        const prefix = `  ${colorCode};1m${name} \u001B[0m`;
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
    } else {
        args[0] = getDate() + name + ' ' + args[0];
    }
}
function getDate() {
    if (exports.inspectOpts.hideDate) {
        return '';
    }
    return new Date().toISOString() + ' ';
}
/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */ function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    if (namespaces) {
        process.env.DEBUG = namespaces;
    } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    return process.env.DEBUG;
}
/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */ function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for(let i = 0; i < keys.length; i++){
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
}
module.exports = __turbopack_require__("[project]/node_modules/debug/src/common.js [app-route] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %o to `util.inspect()`, all on a single line.
 */ formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split('\n').map((str)=>str.trim()).join(' ');
};
/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */ formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
};
}}),
"[project]/node_modules/debug/src/browser.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33'
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
    }
    let m;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    // eslint-disable-next-line no-return-assign
    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
    if (!this.useColors) {
        return;
    }
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === '%%') {
            return;
        }
        index++;
        if (match === '%c') {
            // We only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
        }
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) {
            exports.storage.setItem('debug', namespaces);
        } else {
            exports.storage.removeItem('debug');
        }
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem('debug');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
    }
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = __turbopack_require__("[project]/node_modules/debug/src/common.js [app-route] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
    }
};
}}),
"[project]/node_modules/debug/src/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */ if (typeof process === 'undefined' || process.type === 'renderer' || ("TURBOPACK compile-time value", false) === true || process.__nwjs) {
    module.exports = __turbopack_require__("[project]/node_modules/debug/src/browser.js [app-route] (ecmascript)");
} else {
    module.exports = __turbopack_require__("[project]/node_modules/debug/src/node.js [app-route] (ecmascript)");
}
}}),
"[project]/node_modules/has-flag/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
module.exports = (flag, argv = process.argv)=>{
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};
}}),
"[project]/node_modules/supports-color/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
const os = __turbopack_require__("[externals]/os [external] (os, cjs)");
const tty = __turbopack_require__("[externals]/tty [external] (tty, cjs)");
const hasFlag = __turbopack_require__("[project]/node_modules/has-flag/index.js [app-route] (ecmascript)");
const { env } = process;
let forceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    forceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    forceColor = 1;
}
if ('FORCE_COLOR' in env) {
    if (env.FORCE_COLOR === 'true') {
        forceColor = 1;
    } else if (env.FORCE_COLOR === 'false') {
        forceColor = 0;
    } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
}
function translateLevel(level) {
    if (level === 0) {
        return false;
    }
    return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
        return 0;
    }
    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
        return 3;
    }
    if (hasFlag('color=256')) {
        return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
        return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === 'dumb') {
        return min;
    }
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    if ('CI' in env) {
        if ([
            'TRAVIS',
            'CIRCLECI',
            'APPVEYOR',
            'GITLAB_CI',
            'GITHUB_ACTIONS',
            'BUILDKITE'
        ].some((sign)=>sign in env) || env.CI_NAME === 'codeship') {
            return 1;
        }
        return min;
    }
    if ('TEAMCITY_VERSION' in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === 'truecolor') {
        return 3;
    }
    if ('TERM_PROGRAM' in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
        switch(env.TERM_PROGRAM){
            case 'iTerm.app':
                return version >= 3 ? 3 : 2;
            case 'Apple_Terminal':
                return 2;
        }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
    }
    if ('COLORTERM' in env) {
        return 1;
    }
    return min;
}
function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
}
module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};
}}),
"[project]/node_modules/follow-redirects/debug.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var debug;
module.exports = function() {
    if (!debug) {
        try {
            /* eslint global-require: off */ debug = __turbopack_require__("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")("follow-redirects");
        } catch (error) {}
        if (typeof debug !== "function") {
            debug = function() {};
        }
    }
    debug.apply(null, arguments);
};
}}),
"[project]/node_modules/follow-redirects/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
var url = __turbopack_require__("[externals]/url [external] (url, cjs)");
var URL = url.URL;
var http = __turbopack_require__("[externals]/http [external] (http, cjs)");
var https = __turbopack_require__("[externals]/https [external] (https, cjs)");
var Writable = __turbopack_require__("[externals]/stream [external] (stream, cjs)").Writable;
var assert = __turbopack_require__("[externals]/assert [external] (assert, cjs)");
var debug = __turbopack_require__("[project]/node_modules/follow-redirects/debug.js [app-route] (ecmascript)");
// Preventive platform detection
// istanbul ignore next
(function detectUnsupportedEnvironment() {
    var looksLikeNode = typeof process !== "undefined";
    var looksLikeBrowser = "undefined" !== "undefined" && typeof document !== "undefined";
    var looksLikeV8 = isFunction(Error.captureStackTrace);
    if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
    }
})();
// Whether to use the native URL object or the legacy url module
var useNativeURL = false;
try {
    assert(new URL(""));
} catch (error) {
    useNativeURL = error.code === "ERR_INVALID_URL";
}
// URL fields to preserve in copy operations
var preservedUrlFields = [
    "auth",
    "host",
    "hostname",
    "href",
    "path",
    "pathname",
    "port",
    "protocol",
    "query",
    "search",
    "hash"
];
// Create handlers that pass events from native requests
var events = [
    "abort",
    "aborted",
    "connect",
    "error",
    "socket",
    "timeout"
];
var eventHandlers = Object.create(null);
events.forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
    };
});
// Error types with codes
var InvalidUrlError = createErrorType("ERR_INVALID_URL", "Invalid URL", TypeError);
var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded", RedirectionError);
var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
// istanbul ignore next
var destroy = Writable.prototype.destroy || noop;
// An HTTP(S) request that can be redirected
function RedirectableRequest(options, responseCallback) {
    // Initialize the request
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    // Attach a callback if passed
    if (responseCallback) {
        this.on("response", responseCallback);
    }
    // React to responses of native requests
    var self = this;
    this._onNativeResponse = function(response) {
        try {
            self._processResponse(response);
        } catch (cause) {
            self.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({
                cause: cause
            }));
        }
    };
    // Perform the first request
    this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);
RedirectableRequest.prototype.abort = function() {
    destroyRequest(this._currentRequest);
    this._currentRequest.abort();
    this.emit("abort");
};
RedirectableRequest.prototype.destroy = function(error) {
    destroyRequest(this._currentRequest, error);
    destroy.call(this, error);
    return this;
};
// Writes buffered data to the current native request
RedirectableRequest.prototype.write = function(data, encoding, callback) {
    // Writing is not allowed if end has been called
    if (this._ending) {
        throw new WriteAfterEndError();
    }
    // Validate input and shift parameters if necessary
    if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
    }
    // Ignore empty buffers, since writing them doesn't invoke the callback
    // https://github.com/nodejs/node/issues/22066
    if (data.length === 0) {
        if (callback) {
            callback();
        }
        return;
    }
    // Only write when we don't exceed the maximum body length
    if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({
            data: data,
            encoding: encoding
        });
        this._currentRequest.write(data, encoding, callback);
    } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
    }
};
// Ends the current native request
RedirectableRequest.prototype.end = function(data, encoding, callback) {
    // Shift parameters if necessary
    if (isFunction(data)) {
        callback = data;
        data = encoding = null;
    } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
    }
    // Write data if needed and end
    if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
    } else {
        var self = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
            self._ended = true;
            currentRequest.end(null, null, callback);
        });
        this._ending = true;
    }
};
// Sets a header value on the current native request
RedirectableRequest.prototype.setHeader = function(name, value) {
    this._options.headers[name] = value;
    this._currentRequest.setHeader(name, value);
};
// Clears a header value on the current native request
RedirectableRequest.prototype.removeHeader = function(name) {
    delete this._options.headers[name];
    this._currentRequest.removeHeader(name);
};
// Global timeout for all underlying requests
RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    var self = this;
    // Destroys the socket on timeout
    function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
    }
    // Sets up a timer to trigger a timeout event
    function startTimer(socket) {
        if (self._timeout) {
            clearTimeout(self._timeout);
        }
        self._timeout = setTimeout(function() {
            self.emit("timeout");
            clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
    }
    // Stops a timeout from triggering
    function clearTimer() {
        // Clear the timeout
        if (self._timeout) {
            clearTimeout(self._timeout);
            self._timeout = null;
        }
        // Clean up all attached listeners
        self.removeListener("abort", clearTimer);
        self.removeListener("error", clearTimer);
        self.removeListener("response", clearTimer);
        self.removeListener("close", clearTimer);
        if (callback) {
            self.removeListener("timeout", callback);
        }
        if (!self.socket) {
            self._currentRequest.removeListener("socket", startTimer);
        }
    }
    // Attach callback if passed
    if (callback) {
        this.on("timeout", callback);
    }
    // Start the timer if or when the socket is opened
    if (this.socket) {
        startTimer(this.socket);
    } else {
        this._currentRequest.once("socket", startTimer);
    }
    // Clean up on events
    this.on("socket", destroyOnTimeout);
    this.on("abort", clearTimer);
    this.on("error", clearTimer);
    this.on("response", clearTimer);
    this.on("close", clearTimer);
    return this;
};
// Proxy all other public ClientRequest methods
[
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
    };
});
// Proxy all public ClientRequest properties
[
    "aborted",
    "connection",
    "socket"
].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
            return this._currentRequest[property];
        }
    });
});
RedirectableRequest.prototype._sanitizeOptions = function(options) {
    // Ensure headers are always present
    if (!options.headers) {
        options.headers = {};
    }
    // Since http.request treats host as an alias of hostname,
    // but the url module interprets host as hostname plus port,
    // eliminate the host property to avoid confusion.
    if (options.host) {
        // Use hostname if set, because it has precedence
        if (!options.hostname) {
            options.hostname = options.host;
        }
        delete options.host;
    }
    // Complete the URL object when necessary
    if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
            options.pathname = options.path;
        } else {
            options.pathname = options.path.substring(0, searchPos);
            options.search = options.path.substring(searchPos);
        }
    }
};
// Executes the next native request (initial or redirect)
RedirectableRequest.prototype._performRequest = function() {
    // Load the native protocol
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
    }
    // If specified, use the agent corresponding to the protocol
    // (HTTP and HTTPS use different types of agents)
    if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
    }
    // Create the native request and set up its event handlers
    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    request._redirectable = this;
    for (var event of events){
        request.on(event, eventHandlers[event]);
    }
    // RFC7230§5.3.1: When making a request directly to an origin server, […]
    // a client MUST send only the absolute path […] as the request-target.
    this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : // When making a request to a proxy, […]
    // a client MUST send the target URI in absolute-form […].
    this._options.path;
    // End a redirected request
    // (The first request must be ended explicitly with RedirectableRequest#end)
    if (this._isRedirect) {
        // Write the request entity and end
        var i = 0;
        var self = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
            // Only write if this request has not been redirected yet
            // istanbul ignore else
            if (request === self._currentRequest) {
                // Report any write errors
                // istanbul ignore if
                if (error) {
                    self.emit("error", error);
                } else if (i < buffers.length) {
                    var buffer = buffers[i++];
                    // istanbul ignore else
                    if (!request.finished) {
                        request.write(buffer.data, buffer.encoding, writeNext);
                    }
                } else if (self._ended) {
                    request.end();
                }
            }
        })();
    }
};
// Processes a response from the current native request
RedirectableRequest.prototype._processResponse = function(response) {
    // Store the redirected response
    var statusCode = response.statusCode;
    if (this._options.trackRedirects) {
        this._redirects.push({
            url: this._currentUrl,
            headers: response.headers,
            statusCode: statusCode
        });
    }
    // RFC7231§6.4: The 3xx (Redirection) class of status code indicates
    // that further action needs to be taken by the user agent in order to
    // fulfill the request. If a Location header field is provided,
    // the user agent MAY automatically redirect its request to the URI
    // referenced by the Location field value,
    // even if the specific status code is not understood.
    // If the response is not a redirect; return it as-is
    var location = response.headers.location;
    if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        // Clean up
        this._requestBodyBuffers = [];
        return;
    }
    // The response is a redirect, so abort the current request
    destroyRequest(this._currentRequest);
    // Discard the remainder of the response to avoid waiting for data
    response.destroy();
    // RFC7231§6.4: A client SHOULD detect and intervene
    // in cyclical redirections (i.e., "infinite" redirection loops).
    if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
    }
    // Store the request headers if applicable
    var requestHeaders;
    var beforeRedirect = this._options.beforeRedirect;
    if (beforeRedirect) {
        requestHeaders = Object.assign({
            // The Host header was set by nativeProtocol.request
            Host: response.req.getHeader("host")
        }, this._options.headers);
    }
    // RFC7231§6.4: Automatic redirection needs to done with
    // care for methods not known to be safe, […]
    // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change
    // the request method from POST to GET for the subsequent request.
    var method = this._options.method;
    if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
    // the server is redirecting the user agent to a different resource […]
    // A user agent can perform a retrieval request targeting that URI
    // (a GET or HEAD request if using HTTP) […]
    statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        // Drop a possible entity and headers related to it
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
    }
    // Drop the Host header, as the redirect might lead to a different host
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
    // If the redirect is relative, carry over the host of the last request
    var currentUrlParts = parseUrl(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, {
        host: currentHost
    }));
    // Create the redirected request
    var redirectUrl = resolveUrl(location, currentUrl);
    debug("redirecting to", redirectUrl.href);
    this._isRedirect = true;
    spreadUrlObject(redirectUrl, this._options);
    // Drop confidential headers when redirecting to a less secure protocol
    // or to a different domain that is not a superdomain
    if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
    }
    // Evaluate the beforeRedirect callback
    if (isFunction(beforeRedirect)) {
        var responseDetails = {
            headers: response.headers,
            statusCode: statusCode
        };
        var requestDetails = {
            url: currentUrl,
            method: method,
            headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
    }
    // Perform the redirected request
    this._performRequest();
};
// Wraps the key/value object of protocols with redirect functionality
function wrap(protocols) {
    // Default settings
    var exports = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
    };
    // Wrap each protocol
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);
        // Executes a request, following redirects
        function request(input, options, callback) {
            // Parse parameters, ensuring that input is an object
            if (isURL(input)) {
                input = spreadUrlObject(input);
            } else if (isString(input)) {
                input = spreadUrlObject(parseUrl(input));
            } else {
                callback = options;
                options = validateUrl(input);
                input = {
                    protocol: protocol
                };
            }
            if (isFunction(options)) {
                callback = options;
                options = null;
            }
            // Set defaults
            options = Object.assign({
                maxRedirects: exports.maxRedirects,
                maxBodyLength: exports.maxBodyLength
            }, input, options);
            options.nativeProtocols = nativeProtocols;
            if (!isString(options.host) && !isString(options.hostname)) {
                options.hostname = "::1";
            }
            assert.equal(options.protocol, protocol, "protocol mismatch");
            debug("options", options);
            return new RedirectableRequest(options, callback);
        }
        // Executes a GET request, following redirects
        function get(input, options, callback) {
            var wrappedRequest = wrappedProtocol.request(input, options, callback);
            wrappedRequest.end();
            return wrappedRequest;
        }
        // Expose the properties on the wrapped protocol
        Object.defineProperties(wrappedProtocol, {
            request: {
                value: request,
                configurable: true,
                enumerable: true,
                writable: true
            },
            get: {
                value: get,
                configurable: true,
                enumerable: true,
                writable: true
            }
        });
    });
    return exports;
}
function noop() {}
function parseUrl(input) {
    var parsed;
    // istanbul ignore else
    if (useNativeURL) {
        parsed = new URL(input);
    } else {
        // Ensure the URL is valid and absolute
        parsed = validateUrl(url.parse(input));
        if (!isString(parsed.protocol)) {
            throw new InvalidUrlError({
                input
            });
        }
    }
    return parsed;
}
function resolveUrl(relative, base) {
    // istanbul ignore next
    return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));
}
function validateUrl(input) {
    if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({
            input: input.href || input
        });
    }
    if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({
            input: input.href || input
        });
    }
    return input;
}
function spreadUrlObject(urlObject, target) {
    var spread = target || {};
    for (var key of preservedUrlFields){
        spread[key] = urlObject[key];
    }
    // Fix IPv6 hostname
    if (spread.hostname.startsWith("[")) {
        spread.hostname = spread.hostname.slice(1, -1);
    }
    // Ensure port is a number
    if (spread.port !== "") {
        spread.port = Number(spread.port);
    }
    // Concatenate path
    spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
    return spread;
}
function removeMatchingHeaders(regex, headers) {
    var lastValue;
    for(var header in headers){
        if (regex.test(header)) {
            lastValue = headers[header];
            delete headers[header];
        }
    }
    return lastValue === null || typeof lastValue === "undefined" ? undefined : String(lastValue).trim();
}
function createErrorType(code, message, baseClass) {
    // Create constructor
    function CustomError(properties) {
        // istanbul ignore else
        if (isFunction(Error.captureStackTrace)) {
            Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
    }
    // Attach constructor and set default properties
    CustomError.prototype = new (baseClass || Error)();
    Object.defineProperties(CustomError.prototype, {
        constructor: {
            value: CustomError,
            enumerable: false
        },
        name: {
            value: "Error [" + code + "]",
            enumerable: false
        }
    });
    return CustomError;
}
function destroyRequest(request, error) {
    for (var event of events){
        request.removeListener(event, eventHandlers[event]);
    }
    request.on("error", noop);
    request.destroy(error);
}
function isSubdomain(subdomain, domain) {
    assert(isString(subdomain) && isString(domain));
    var dot = subdomain.length - domain.length - 1;
    return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}
function isString(value) {
    return typeof value === "string" || value instanceof String;
}
function isFunction(value) {
    return typeof value === "function";
}
function isBuffer(value) {
    return typeof value === "object" && "length" in value;
}
function isURL(value) {
    return URL && value instanceof URL;
}
// Exports
module.exports = wrap({
    http: http,
    https: https
});
module.exports.wrap = wrap;
}}),
"[project]/node_modules/google-spreadsheet/dist/index.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "GoogleSpreadsheet": (()=>E),
    "GoogleSpreadsheetCell": (()=>$),
    "GoogleSpreadsheetCellErrorValue": (()=>b),
    "GoogleSpreadsheetRow": (()=>S),
    "GoogleSpreadsheetWorksheet": (()=>V)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$compact$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/compact.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$each$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/each.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$filter$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/filter.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$find$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/find.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/flatten.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$get$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/get.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$groupBy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/groupBy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isArray$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/isArray.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isBoolean$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/isBoolean.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/isEqual.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isFinite$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/isFinite.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isInteger$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/isInteger.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isNil$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/isNil.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isNumber$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/isNumber.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isObject$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/isObject.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isString$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/isString.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$keyBy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/keyBy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$keys$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/keys.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$map$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/map.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$omit$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/omit.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pickBy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/pickBy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$set$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/set.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$some$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/some.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$sortBy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/sortBy.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$times$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/times.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$unset$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/unset.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$values$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/lodash/values.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/axios/lib/axios.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
function v(s) {
    let e = "";
    const t = Object.keys(s).filter((r)=>r !== "gridProperties").join(",");
    return s.gridProperties && (e = Object.keys(s.gridProperties).map((r)=>`gridProperties.${r}`).join(","), e.length && t.length && (e = `${e},`)), e + t;
}
function R(s) {
    let e, t = "", r = s;
    for(; r > 0;)e = (r - 1) % 26, t = String.fromCharCode(e + 65) + t, r = (r - e - 1) / 26;
    return t;
}
function Q(s) {
    let e = 0;
    const { length: t } = s;
    for(let r = 0; r < t; r++)e += (s.charCodeAt(r) - 64) * 26 ** (t - r - 1);
    return e;
}
function D(s) {
    let e = "";
    return Object.keys(s).forEach((t)=>{
        const r = typeof s[t] == "object", a = r && s[t].length >= 0;
        if (r || (e += `${t}=${encodeURIComponent(s[t])}&`), r && a) for (const o of s[t])e += `${t}=${encodeURIComponent(o)}&`;
    }), e && e.slice(0, -1);
}
function F(s) {
    const e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$groupBy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(s);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$each$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e, (t, r)=>{
        if (r && t.length > 1) throw new Error(`Duplicate header detected: "${r}". Please make sure all non-empty headers are unique`);
    });
}
class S {
    constructor(e, t, r){
        this._worksheet = e, this._rowNumber = t, this._rawData = r, this._deleted = !1;
    }
    get deleted() {
        return this._deleted;
    }
    get rowNumber() {
        return this._rowNumber;
    }
    _updateRowNumber(e) {
        this._rowNumber = e;
    }
    get a1Range() {
        return [
            this._worksheet.a1SheetName,
            "!",
            `A${this._rowNumber}`,
            ":",
            `${R(this._worksheet.headerValues.length)}${this._rowNumber}`
        ].join("");
    }
    get(e) {
        const t = this._worksheet.headerValues.indexOf(e);
        return this._rawData[t];
    }
    set(e, t) {
        const r = this._worksheet.headerValues.indexOf(e);
        this._rawData[r] = t;
    }
    assign(e) {
        for(const t in e)this.set(t, e[t]);
    }
    toObject() {
        const e = {};
        for(let t = 0; t < this._worksheet.headerValues.length; t++){
            const r = this._worksheet.headerValues[t];
            r && (e[r] = this._rawData[t]);
        }
        return e;
    }
    async save(e) {
        if (this._deleted) throw new Error("This row has been deleted - call getRows again before making updates.");
        const t = await this._worksheet._spreadsheet.sheetsApi.request({
            method: "put",
            url: `/values/${encodeURIComponent(this.a1Range)}`,
            params: {
                valueInputOption: e?.raw ? "RAW" : "USER_ENTERED",
                includeValuesInResponse: !0
            },
            data: {
                range: this.a1Range,
                majorDimension: "ROWS",
                values: [
                    this._rawData
                ]
            }
        });
        this._rawData = t.data.updatedData.values[0];
    }
    async delete() {
        if (this._deleted) throw new Error("This row has been deleted - call getRows again before making updates.");
        const e = await this._worksheet._makeSingleUpdateRequest("deleteRange", {
            range: {
                sheetId: this._worksheet.sheetId,
                startRowIndex: this._rowNumber - 1,
                endRowIndex: this._rowNumber
            },
            shiftDimension: "ROWS"
        });
        return this._deleted = !0, this._worksheet._shiftRowCache(this.rowNumber), e;
    }
    _clearRowData() {
        for(let e = 0; e < this._rawData.length; e++)this._rawData[e] = "";
    }
}
class b {
    constructor(e){
        this.type = e.type, this.message = e.message;
    }
}
class $ {
    constructor(e, t, r, a){
        this._sheet = e, this._rowIndex = t, this._columnIndex = r, this._draftData = {}, this._updateRawData(a), this._rawData = a;
    }
    _updateRawData(e) {
        this._rawData = e, this._draftData = {}, this._rawData?.effectiveValue && "errorValue" in this._rawData.effectiveValue ? this._error = new b(this._rawData.effectiveValue.errorValue) : this._error = void 0;
    }
    get rowIndex() {
        return this._rowIndex;
    }
    get columnIndex() {
        return this._columnIndex;
    }
    get a1Column() {
        return R(this._columnIndex + 1);
    }
    get a1Row() {
        return this._rowIndex + 1;
    }
    get a1Address() {
        return `${this.a1Column}${this.a1Row}`;
    }
    get value() {
        if (this._draftData.value !== void 0) throw new Error("Value has been changed");
        return this._error ? this._error : this._rawData?.effectiveValue ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$values$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this._rawData.effectiveValue)[0] : null;
    }
    set value(e) {
        if (e instanceof b) throw new Error("You can't manually set a value to an error");
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isBoolean$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e)) this._draftData.valueType = "boolValue";
        else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isString$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e)) e.substring(0, 1) === "=" ? this._draftData.valueType = "formulaValue" : this._draftData.valueType = "stringValue";
        else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isFinite$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e)) this._draftData.valueType = "numberValue";
        else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isNil$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e)) this._draftData.valueType = "stringValue", e = "";
        else throw new Error("Set value to boolean, string, or number");
        this._draftData.value = e;
    }
    get valueType() {
        return this._error ? "errorValue" : this._rawData?.effectiveValue ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$keys$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this._rawData.effectiveValue)[0] : null;
    }
    get formattedValue() {
        return this._rawData?.formattedValue || null;
    }
    get formula() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$get$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this._rawData, "userEnteredValue.formulaValue", null);
    }
    set formula(e) {
        if (!e) throw new Error("To clear a formula, set `cell.value = null`");
        if (e.substring(0, 1) !== "=") throw new Error('formula must begin with "="');
        this.value = e;
    }
    get formulaError() {
        return this._error;
    }
    get errorValue() {
        return this._error;
    }
    get numberValue() {
        if (this.valueType === "numberValue") return this.value;
    }
    set numberValue(e) {
        this.value = e;
    }
    get boolValue() {
        if (this.valueType === "boolValue") return this.value;
    }
    set boolValue(e) {
        this.value = e;
    }
    get stringValue() {
        if (this.valueType === "stringValue") return this.value;
    }
    set stringValue(e) {
        if (e?.startsWith("=")) throw new Error("Use cell.formula to set formula values");
        this.value = e;
    }
    get hyperlink() {
        if (this._draftData.value) throw new Error("Save cell to be able to read hyperlink");
        return this._rawData?.hyperlink;
    }
    get note() {
        return this._draftData.note !== void 0 ? this._draftData.note : this._rawData?.note;
    }
    set note(e) {
        if ((e == null || e === !1) && (e = ""), !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isString$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e)) throw new Error("Note must be a string");
        e === this._rawData?.note ? delete this._draftData.note : this._draftData.note = e;
    }
    get userEnteredFormat() {
        return Object.freeze(this._rawData?.userEnteredFormat);
    }
    get effectiveFormat() {
        return Object.freeze(this._rawData?.effectiveFormat);
    }
    _getFormatParam(e) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$get$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this._draftData, `userEnteredFormat.${e}`)) throw new Error("User format is unsaved - save the cell to be able to read it again");
        return Object.freeze(this._rawData.userEnteredFormat[e]);
    }
    _setFormatParam(e, t) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isEqual$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(t, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$get$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this._rawData, `userEnteredFormat.${e}`)) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$unset$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this._draftData, `userEnteredFormat.${e}`) : ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$set$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this._draftData, `userEnteredFormat.${e}`, t), this._draftData.clearFormat = !1);
    }
    get numberFormat() {
        return this._getFormatParam("numberFormat");
    }
    get backgroundColor() {
        return this._getFormatParam("backgroundColor");
    }
    get backgroundColorStyle() {
        return this._getFormatParam("backgroundColorStyle");
    }
    get borders() {
        return this._getFormatParam("borders");
    }
    get padding() {
        return this._getFormatParam("padding");
    }
    get horizontalAlignment() {
        return this._getFormatParam("horizontalAlignment");
    }
    get verticalAlignment() {
        return this._getFormatParam("verticalAlignment");
    }
    get wrapStrategy() {
        return this._getFormatParam("wrapStrategy");
    }
    get textDirection() {
        return this._getFormatParam("textDirection");
    }
    get textFormat() {
        return this._getFormatParam("textFormat");
    }
    get hyperlinkDisplayType() {
        return this._getFormatParam("hyperlinkDisplayType");
    }
    get textRotation() {
        return this._getFormatParam("textRotation");
    }
    set numberFormat(e) {
        this._setFormatParam("numberFormat", e);
    }
    set backgroundColor(e) {
        this._setFormatParam("backgroundColor", e);
    }
    set backgroundColorStyle(e) {
        this._setFormatParam("backgroundColorStyle", e);
    }
    set borders(e) {
        this._setFormatParam("borders", e);
    }
    set padding(e) {
        this._setFormatParam("padding", e);
    }
    set horizontalAlignment(e) {
        this._setFormatParam("horizontalAlignment", e);
    }
    set verticalAlignment(e) {
        this._setFormatParam("verticalAlignment", e);
    }
    set wrapStrategy(e) {
        this._setFormatParam("wrapStrategy", e);
    }
    set textDirection(e) {
        this._setFormatParam("textDirection", e);
    }
    set textFormat(e) {
        this._setFormatParam("textFormat", e);
    }
    set hyperlinkDisplayType(e) {
        this._setFormatParam("hyperlinkDisplayType", e);
    }
    set textRotation(e) {
        this._setFormatParam("textRotation", e);
    }
    clearAllFormatting() {
        this._draftData.clearFormat = !0, delete this._draftData.userEnteredFormat;
    }
    get _isDirty() {
        return !!(this._draftData.note !== void 0 || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$keys$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this._draftData.userEnteredFormat).length || this._draftData.clearFormat || this._draftData.value !== void 0);
    }
    discardUnsavedChanges() {
        this._draftData = {};
    }
    async save() {
        await this._sheet.saveCells([
            this
        ]);
    }
    _getUpdateRequest() {
        const e = this._draftData.value !== void 0, t = this._draftData.note !== void 0, r = !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$keys$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this._draftData.userEnteredFormat || {}).length, a = this._draftData.clearFormat;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$some$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])([
            e,
            t,
            r,
            a
        ])) return null;
        const o = {
            ...this._rawData?.userEnteredFormat,
            ...this._draftData.userEnteredFormat
        };
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$get$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this._draftData, "userEnteredFormat.backgroundColor") && delete o.backgroundColorStyle, {
            updateCells: {
                rows: [
                    {
                        values: [
                            {
                                ...e && {
                                    userEnteredValue: {
                                        [this._draftData.valueType]: this._draftData.value
                                    }
                                },
                                ...t && {
                                    note: this._draftData.note
                                },
                                ...r && {
                                    userEnteredFormat: o
                                },
                                ...a && {
                                    userEnteredFormat: {}
                                }
                            }
                        ]
                    }
                ],
                fields: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$keys$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$pickBy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
                    userEnteredValue: e,
                    note: t,
                    userEnteredFormat: r || a
                })).join(","),
                start: {
                    sheetId: this._sheet.sheetId,
                    rowIndex: this.rowIndex,
                    columnIndex: this.columnIndex
                }
            }
        };
    }
}
class V {
    constructor(e, t, r){
        this._spreadsheet = e, this._headerRowIndex = 1, this._rawProperties = null, this._cells = [], this._rowMetadata = [], this._columnMetadata = [], this._rowCache = [], this._headerRowIndex = 1, this._rawProperties = t, this._cells = [], this._rowMetadata = [], this._columnMetadata = [], r && this._fillCellData(r);
    }
    get headerValues() {
        if (!this._headerValues) throw new Error("Header values are not yet loaded");
        return this._headerValues;
    }
    updateRawData(e, t) {
        this._rawProperties = e, this._fillCellData(t);
    }
    async _makeSingleUpdateRequest(e, t) {
        return this._spreadsheet._makeSingleUpdateRequest(e, {
            ...t
        });
    }
    _ensureInfoLoaded() {
        if (!this._rawProperties) throw new Error("You must call `doc.loadInfo()` again before accessing this property");
    }
    resetLocalCache(e) {
        e || (this._rawProperties = null), this._headerValues = void 0, this._headerRowIndex = 1, this._cells = [];
    }
    _fillCellData(e) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$each$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e, (t)=>{
            const r = t.startRow || 0, a = t.startColumn || 0, o = t.rowMetadata.length, h = t.columnMetadata.length;
            for(let i = 0; i < o; i++){
                const d = r + i;
                for(let n = 0; n < h; n++){
                    const l = a + n;
                    this._cells[d] || (this._cells[d] = []);
                    const P = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$get$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(t, `rowData[${i}].values[${n}]`);
                    this._cells[d][l] ? this._cells[d][l]._updateRawData(P) : this._cells[d][l] = new $(this, d, l, P);
                }
            }
            for(let i = 0; i < t.rowMetadata.length; i++)this._rowMetadata[r + i] = t.rowMetadata[i];
            for(let i = 0; i < t.columnMetadata.length; i++)this._columnMetadata[a + i] = t.columnMetadata[i];
        });
    }
    _addSheetIdToRange(e) {
        if (e.sheetId && e.sheetId !== this.sheetId) throw new Error("Leave sheet ID blank or set to matching ID of this sheet");
        return {
            ...e,
            sheetId: this.sheetId
        };
    }
    _getProp(e) {
        return this._ensureInfoLoaded(), this._rawProperties[e];
    }
    _setProp(e, t) {
        throw new Error("Do not update directly - use `updateProperties()`");
    }
    get sheetId() {
        return this._getProp("sheetId");
    }
    get title() {
        return this._getProp("title");
    }
    get index() {
        return this._getProp("index");
    }
    get sheetType() {
        return this._getProp("sheetType");
    }
    get gridProperties() {
        return this._getProp("gridProperties");
    }
    get hidden() {
        return this._getProp("hidden");
    }
    get tabColor() {
        return this._getProp("tabColor");
    }
    get rightToLeft() {
        return this._getProp("rightToLeft");
    }
    get _headerRange() {
        return `A${this._headerRowIndex}:${this.lastColumnLetter}${this._headerRowIndex}`;
    }
    set sheetId(e) {
        this._setProp("sheetId", e);
    }
    set title(e) {
        this._setProp("title", e);
    }
    set index(e) {
        this._setProp("index", e);
    }
    set sheetType(e) {
        this._setProp("sheetType", e);
    }
    set gridProperties(e) {
        this._setProp("gridProperties", e);
    }
    set hidden(e) {
        this._setProp("hidden", e);
    }
    set tabColor(e) {
        this._setProp("tabColor", e);
    }
    set rightToLeft(e) {
        this._setProp("rightToLeft", e);
    }
    get rowCount() {
        return this._ensureInfoLoaded(), this.gridProperties.rowCount;
    }
    get columnCount() {
        return this._ensureInfoLoaded(), this.gridProperties.columnCount;
    }
    get a1SheetName() {
        return `'${this.title.replace(/'/g, "''")}'`;
    }
    get encodedA1SheetName() {
        return encodeURIComponent(this.a1SheetName);
    }
    get lastColumnLetter() {
        return this.columnCount ? R(this.columnCount) : "";
    }
    get cellStats() {
        let e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this._cells);
        return e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$compact$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e), {
            nonEmpty: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$filter$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e, (t)=>t.value).length,
            loaded: e.length,
            total: this.rowCount * this.columnCount
        };
    }
    getCellByA1(e) {
        const t = e.match(/([A-Z]+)([0-9]+)/);
        if (!t) throw new Error(`Cell address "${e}" not valid`);
        const r = Q(t[1]), a = parseInt(t[2]);
        return this.getCell(a - 1, r - 1);
    }
    getCell(e, t) {
        if (e < 0 || t < 0) throw new Error("Min coordinate is 0, 0");
        if (e >= this.rowCount || t >= this.columnCount) throw new Error(`Out of bounds, sheet is ${this.rowCount} by ${this.columnCount}`);
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$get$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this._cells, `[${e}][${t}]`)) throw new Error("This cell has not been loaded yet");
        return this._cells[e][t];
    }
    async loadCells(e) {
        if (!e) return this._spreadsheet.loadCells(this.a1SheetName);
        const t = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isArray$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e) ? e : [
            e
        ], r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$map$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(t, (a)=>{
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isString$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(a)) return a.startsWith(this.a1SheetName) ? a : `${this.a1SheetName}!${a}`;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isObject$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(a)) {
                const o = a;
                if (o.sheetId && o.sheetId !== this.sheetId) throw new Error("Leave sheet ID blank or set to matching ID of this sheet");
                return {
                    sheetId: this.sheetId,
                    ...a
                };
            }
            throw new Error("Each filter must be a A1 range string or gridrange object");
        });
        return this._spreadsheet.loadCells(r);
    }
    async saveUpdatedCells() {
        const e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$filter$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$flatten$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this._cells), {
            _isDirty: !0
        });
        e.length && await this.saveCells(e);
    }
    async saveCells(e) {
        const t = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$map$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e, (a)=>a._getUpdateRequest()), r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$map$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e, (a)=>`${this.a1SheetName}!${a.a1Address}`);
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$compact$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(t).length) throw new Error("At least one cell must have something to update");
        await this._spreadsheet._makeBatchUpdateRequest(t, r);
    }
    async _ensureHeaderRowLoaded() {
        this._headerValues || await this.loadHeaderRow();
    }
    async loadHeaderRow(e) {
        e !== void 0 && (this._headerRowIndex = e);
        const t = await this.getCellsInRange(this._headerRange);
        this._processHeaderRow(t);
    }
    _processHeaderRow(e) {
        if (!e) throw new Error("No values in the header row - fill the first row with header values before trying to interact with rows");
        if (this._headerValues = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$map$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e[0], (t)=>t?.trim()), !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$compact$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this.headerValues).length) throw new Error("All your header cells are blank - fill the first row with header values before trying to interact with rows");
        F(this.headerValues);
    }
    async setHeaderRow(e, t) {
        if (!e) return;
        if (e.length > this.columnCount) throw new Error(`Sheet is not large enough to fit ${e.length} columns. Resize the sheet first.`);
        const r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$map$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e, (o)=>o?.trim());
        if (F(r), !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$compact$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(r).length) throw new Error("All your header cells are blank -");
        t && (this._headerRowIndex = t);
        const a = await this._spreadsheet.sheetsApi.request({
            method: "put",
            url: `/values/${this.encodedA1SheetName}!${this._headerRowIndex}:${this._headerRowIndex}`,
            params: {
                valueInputOption: "USER_ENTERED",
                includeValuesInResponse: !0
            },
            data: {
                range: `${this.a1SheetName}!${this._headerRowIndex}:${this._headerRowIndex}`,
                majorDimension: "ROWS",
                values: [
                    [
                        ...r,
                        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$times$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this.columnCount - r.length, ()=>"")
                    ]
                ]
            }
        });
        this._headerValues = a.data.updatedData.values[0];
    }
    async addRows(e, t = {}) {
        if (this.title.includes(":")) throw new Error('Please remove the ":" from your sheet title. There is a bug with the google API which breaks appending rows if any colons are in the sheet title.');
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isArray$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e)) throw new Error("You must pass in an array of row values to append");
        await this._ensureHeaderRowLoaded();
        const r = [];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$each$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e, (i)=>{
            let d;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isArray$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(i)) d = i;
            else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isObject$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(i)) {
                d = [];
                for(let n = 0; n < this.headerValues.length; n++){
                    const l = this.headerValues[n];
                    d[n] = i[l];
                }
            } else throw new Error("Each row must be an object or an array");
            r.push(d);
        });
        const a = await this._spreadsheet.sheetsApi.request({
            method: "post",
            url: `/values/${this.encodedA1SheetName}!A${this._headerRowIndex}:append`,
            params: {
                valueInputOption: t.raw ? "RAW" : "USER_ENTERED",
                insertDataOption: t.insert ? "INSERT_ROWS" : "OVERWRITE",
                includeValuesInResponse: !0
            },
            data: {
                values: r
            }
        }), { updatedRange: o } = a.data.updates;
        let h = o.match(/![A-Z]+([0-9]+):?/)[1];
        return h = parseInt(h), this._ensureInfoLoaded(), t.insert ? this._rawProperties.gridProperties.rowCount += e.length : h + e.length > this.rowCount && (this._rawProperties.gridProperties.rowCount = h + e.length - 1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$map$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(a.data.updates.updatedData.values, (i)=>new S(this, h++, i));
    }
    async addRow(e, t) {
        return (await this.addRows([
            e
        ], t))[0];
    }
    async getRows(e) {
        const t = e?.offset || 0, r = e?.limit || this.rowCount - 1, a = 1 + this._headerRowIndex + t, o = a + r - 1;
        let h;
        if (this._headerValues) {
            const n = R(this.headerValues.length);
            h = await this.getCellsInRange(`A${a}:${n}${o}`);
        } else {
            const n = await this.batchGetCellsInRange([
                this._headerRange,
                `A${a}:${this.lastColumnLetter}${o}`
            ]);
            this._processHeaderRow(n[0]), h = n[1];
        }
        if (!h) return [];
        const i = [];
        let d = a;
        for(let n = 0; n < h.length; n++){
            const l = new S(this, d++, h[n]);
            this._rowCache[l.rowNumber] = l, i.push(l);
        }
        return i;
    }
    _shiftRowCache(e) {
        delete this._rowCache[e], this._rowCache.forEach((t)=>{
            t.rowNumber > e && t._updateRowNumber(t.rowNumber - 1);
        });
    }
    async clearRows(e) {
        const t = e?.start || this._headerRowIndex + 1, r = e?.end || this.rowCount;
        await this._spreadsheet.sheetsApi.post(`/values/${this.encodedA1SheetName}!${t}:${r}:clear`), this._rowCache.forEach((a)=>{
            a.rowNumber >= t && a.rowNumber <= r && a._clearRowData();
        });
    }
    async updateProperties(e) {
        return this._makeSingleUpdateRequest("updateSheetProperties", {
            properties: {
                sheetId: this.sheetId,
                ...e
            },
            fields: v(e)
        });
    }
    async updateGridProperties(e) {
        return this.updateProperties({
            gridProperties: e
        });
    }
    async resize(e) {
        return this.updateGridProperties(e);
    }
    async updateDimensionProperties(e, t, r) {
        return this._makeSingleUpdateRequest("updateDimensionProperties", {
            range: {
                sheetId: this.sheetId,
                dimension: e,
                ...r
            },
            properties: t,
            fields: v(t)
        });
    }
    async getCellsInRange(e, t) {
        return (await this._spreadsheet.sheetsApi.get(`/values/${this.encodedA1SheetName}!${e}`, {
            params: t
        })).data.values;
    }
    async batchGetCellsInRange(e, t) {
        const r = e.map((a)=>`ranges=${this.encodedA1SheetName}!${a}`).join("&");
        return (await this._spreadsheet.sheetsApi.get(`/values:batchGet?${r}`, {
            params: t
        })).data.valueRanges.map((a)=>a.values);
    }
    async updateNamedRange() {}
    async addNamedRange() {}
    async deleteNamedRange() {}
    async repeatCell() {}
    async autoFill() {}
    async cutPaste() {}
    async copyPaste() {}
    async mergeCells(e, t = "MERGE_ALL") {
        await this._makeSingleUpdateRequest("mergeCells", {
            mergeType: t,
            range: this._addSheetIdToRange(e)
        });
    }
    async unmergeCells(e) {
        await this._makeSingleUpdateRequest("unmergeCells", {
            range: this._addSheetIdToRange(e)
        });
    }
    async updateBorders() {}
    async addFilterView() {}
    async appendCells() {}
    async clearBasicFilter() {}
    async deleteDimension() {}
    async deleteEmbeddedObject() {}
    async deleteFilterView() {}
    async duplicateFilterView() {}
    async duplicate(e) {
        const t = (await this._makeSingleUpdateRequest("duplicateSheet", {
            sourceSheetId: this.sheetId,
            ...e?.index !== void 0 && {
                insertSheetIndex: e.index
            },
            ...e?.id && {
                newSheetId: e.id
            },
            ...e?.title && {
                newSheetName: e.title
            }
        })).properties.sheetId;
        return this._spreadsheet.sheetsById[t];
    }
    async findReplace() {}
    async insertDimension(e, t, r) {
        if (!e) throw new Error("You need to specify a dimension. i.e. COLUMNS|ROWS");
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isObject$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(t)) throw new Error("`range` must be an object containing `startIndex` and `endIndex`");
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isInteger$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(t.startIndex) || t.startIndex < 0) throw new Error("range.startIndex must be an integer >=0");
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isInteger$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(t.endIndex) || t.endIndex < 0) throw new Error("range.endIndex must be an integer >=0");
        if (t.endIndex <= t.startIndex) throw new Error("range.endIndex must be greater than range.startIndex");
        if (r === void 0 && (r = t.startIndex > 0), r && t.startIndex === 0) throw new Error("Cannot set inheritFromBefore to true if inserting in first row/column");
        return this._makeSingleUpdateRequest("insertDimension", {
            range: {
                sheetId: this.sheetId,
                dimension: e,
                startIndex: t.startIndex,
                endIndex: t.endIndex
            },
            inheritFromBefore: r
        });
    }
    async insertRange() {}
    async moveDimension() {}
    async updateEmbeddedObjectPosition() {}
    async pasteData() {}
    async textToColumns() {}
    async updateFilterView() {}
    async deleteRange() {}
    async appendDimension() {}
    async addConditionalFormatRule() {}
    async updateConditionalFormatRule() {}
    async deleteConditionalFormatRule() {}
    async sortRange() {}
    async setDataValidation(e, t) {
        return this._makeSingleUpdateRequest("setDataValidation", {
            range: {
                sheetId: this.sheetId,
                ...e
            },
            ...t && {
                rule: t
            }
        });
    }
    async setBasicFilter() {}
    async addProtectedRange() {}
    async updateProtectedRange() {}
    async deleteProtectedRange() {}
    async autoResizeDimensions() {}
    async addChart() {}
    async updateChartSpec() {}
    async updateBanding() {}
    async addBanding() {}
    async deleteBanding() {}
    async createDeveloperMetadata() {}
    async updateDeveloperMetadata() {}
    async deleteDeveloperMetadata() {}
    async randomizeRange() {}
    async addDimensionGroup() {}
    async deleteDimensionGroup() {}
    async updateDimensionGroup() {}
    async trimWhitespace() {}
    async deleteDuplicates() {}
    async addSlicer() {}
    async updateSlicerSpec() {}
    async delete() {
        return this._spreadsheet.deleteSheet(this.sheetId);
    }
    async copyToSpreadsheet(e) {
        return this._spreadsheet.sheetsApi.post(`/sheets/${this.sheetId}:copyTo`, {
            destinationSpreadsheetId: e
        });
    }
    async clear(e) {
        const t = e ? `!${e}` : "";
        await this._spreadsheet.sheetsApi.post(`/values/${this.encodedA1SheetName}${t}:clear`), this.resetLocalCache(!0);
    }
    async downloadAsCSV(e = !1) {
        return this._spreadsheet._downloadAs("csv", this.sheetId, e);
    }
    async downloadAsTSV(e = !1) {
        return this._spreadsheet._downloadAs("tsv", this.sheetId, e);
    }
    async downloadAsPDF(e = !1) {
        return this._spreadsheet._downloadAs("pdf", this.sheetId, e);
    }
}
var m = ((s)=>(s.GOOGLE_AUTH_CLIENT = "google_auth", s.RAW_ACCESS_TOKEN = "raw_access_token", s.API_KEY = "api_key", s))(m || {});
const T = "https://sheets.googleapis.com/v4/spreadsheets", ee = "https://www.googleapis.com/drive/v3/files", N = {
    html: {},
    zip: {},
    xlsx: {},
    ods: {},
    csv: {
        singleWorksheet: !0
    },
    tsv: {
        singleWorksheet: !0
    },
    pdf: {
        singleWorksheet: !0
    }
};
function U(s) {
    if ("getRequestHeaders" in s) return m.GOOGLE_AUTH_CLIENT;
    if ("token" in s && s.token) return m.RAW_ACCESS_TOKEN;
    if ("apiKey" in s && s.apiKey) return m.API_KEY;
    throw new Error("Invalid auth");
}
async function j(s) {
    if ("getRequestHeaders" in s) return {
        headers: await s.getRequestHeaders()
    };
    if ("apiKey" in s && s.apiKey) return {
        params: {
            key: s.apiKey
        }
    };
    if ("token" in s && s.token) return {
        headers: {
            Authorization: `Bearer ${s.token}`
        }
    };
    throw new Error("Invalid auth");
}
class E {
    constructor(e, t){
        this._rawProperties = null, this._spreadsheetUrl = null, this._deleted = !1, this.spreadsheetId = e, this.auth = t, this._rawSheets = {}, this._spreadsheetUrl = null, this.sheetsApi = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].create({
            baseURL: `${T}/${e}`,
            paramsSerializer: D,
            maxContentLength: 1 / 0,
            maxBodyLength: 1 / 0
        }), this.driveApi = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].create({
            baseURL: `${ee}/${e}`,
            paramsSerializer: D
        }), this.sheetsApi.interceptors.request.use(this._setAxiosRequestAuth.bind(this)), this.sheetsApi.interceptors.response.use(this._handleAxiosResponse.bind(this), this._handleAxiosErrors.bind(this)), this.driveApi.interceptors.request.use(this._setAxiosRequestAuth.bind(this)), this.driveApi.interceptors.response.use(this._handleAxiosResponse.bind(this), this._handleAxiosErrors.bind(this));
    }
    get authMode() {
        return U(this.auth);
    }
    async _setAxiosRequestAuth(e) {
        const t = await j(this.auth);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$each$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(t.headers, (r, a)=>{
            e.headers.set(a, r);
        }), e.params = {
            ...e.params,
            ...t.params
        }, e;
    }
    async _handleAxiosResponse(e) {
        return e;
    }
    async _handleAxiosErrors(e) {
        const t = e.response?.data;
        if (t) {
            if (!t.error) throw e;
            const { code: r, message: a } = t.error;
            throw e.message = `Google API error - [${r}] ${a}`, e;
        }
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$get$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e, "response.status") === 403 && "apiKey" in this.auth ? new Error("Sheet is private. Use authentication or make public. (see https://github.com/theoephraim/node-google-spreadsheet#a-note-on-authentication for details)") : e;
    }
    async _makeSingleUpdateRequest(e, t) {
        const r = await this.sheetsApi.post(":batchUpdate", {
            requests: [
                {
                    [e]: t
                }
            ],
            includeSpreadsheetInResponse: !0
        });
        return this._updateRawProperties(r.data.updatedSpreadsheet.properties), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$each$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(r.data.updatedSpreadsheet.sheets, (a)=>this._updateOrCreateSheet(a)), r.data.replies[0][e];
    }
    async _makeBatchUpdateRequest(e, t) {
        const r = await this.sheetsApi.post(":batchUpdate", {
            requests: e,
            includeSpreadsheetInResponse: !0,
            ...t && {
                responseIncludeGridData: !0,
                ...t !== "*" && {
                    responseRanges: t
                }
            }
        });
        this._updateRawProperties(r.data.updatedSpreadsheet.properties), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$each$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(r.data.updatedSpreadsheet.sheets, (a)=>this._updateOrCreateSheet(a));
    }
    _ensureInfoLoaded() {
        if (!this._rawProperties) throw new Error("You must call `doc.loadInfo()` before accessing this property");
    }
    _updateRawProperties(e) {
        this._rawProperties = e;
    }
    _updateOrCreateSheet(e) {
        const { properties: t, data: r } = e, { sheetId: a } = t;
        this._rawSheets[a] ? this._rawSheets[a].updateRawData(t, r) : this._rawSheets[a] = new V(this, t, r);
    }
    _getProp(e) {
        return this._ensureInfoLoaded(), this._rawProperties[e];
    }
    get title() {
        return this._getProp("title");
    }
    get locale() {
        return this._getProp("locale");
    }
    get timeZone() {
        return this._getProp("timeZone");
    }
    get autoRecalc() {
        return this._getProp("autoRecalc");
    }
    get defaultFormat() {
        return this._getProp("defaultFormat");
    }
    get spreadsheetTheme() {
        return this._getProp("spreadsheetTheme");
    }
    get iterativeCalculationSettings() {
        return this._getProp("iterativeCalculationSettings");
    }
    async updateProperties(e) {
        await this._makeSingleUpdateRequest("updateSpreadsheetProperties", {
            properties: e,
            fields: v(e)
        });
    }
    async loadInfo(e = !1) {
        const t = await this.sheetsApi.get("/", {
            params: {
                ...e && {
                    includeGridData: !0
                }
            }
        });
        this._spreadsheetUrl = t.data.spreadsheetUrl, this._rawProperties = t.data.properties, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$each$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(t.data.sheets, (r)=>this._updateOrCreateSheet(r));
    }
    resetLocalCache() {
        this._rawProperties = null, this._rawSheets = {};
    }
    get sheetCount() {
        return this._ensureInfoLoaded(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$values$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this._rawSheets).length;
    }
    get sheetsById() {
        return this._ensureInfoLoaded(), this._rawSheets;
    }
    get sheetsByIndex() {
        return this._ensureInfoLoaded(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$sortBy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this._rawSheets, "index");
    }
    get sheetsByTitle() {
        return this._ensureInfoLoaded(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$keyBy$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(this._rawSheets, "title");
    }
    async addSheet(e = {}) {
        const t = (await this._makeSingleUpdateRequest("addSheet", {
            properties: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$omit$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e, "headerValues", "headerRowIndex")
        })).properties.sheetId, r = this.sheetsById[t];
        return e.headerValues && await r.setHeaderRow(e.headerValues, e.headerRowIndex), r;
    }
    async deleteSheet(e) {
        await this._makeSingleUpdateRequest("deleteSheet", {
            sheetId: e
        }), delete this._rawSheets[e];
    }
    async addNamedRange(e, t, r) {
        return this._makeSingleUpdateRequest("addNamedRange", {
            name: e,
            namedRangeId: r,
            range: t
        });
    }
    async deleteNamedRange(e) {
        return this._makeSingleUpdateRequest("deleteNamedRange", {
            namedRangeId: e
        });
    }
    async loadCells(e) {
        const t = this.authMode === m.API_KEY, r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isArray$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(e) ? e : [
            e
        ], a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$map$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(r, (i)=>{
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isString$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(i)) return t ? i : {
                a1Range: i
            };
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isObject$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(i)) {
                if (t) throw new Error("Only A1 ranges are supported when fetching cells with read-only access (using only an API key)");
                return {
                    gridRange: i
                };
            }
            throw new Error("Each filter must be an A1 range string or a gridrange object");
        });
        let o;
        this.authMode === m.API_KEY ? o = await this.sheetsApi.get("/", {
            params: {
                includeGridData: !0,
                ranges: a
            }
        }) : o = await this.sheetsApi.post(":getByDataFilter", {
            includeGridData: !0,
            dataFilters: a
        });
        const { sheets: h } = o.data;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$each$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(h, (i)=>{
            this._updateOrCreateSheet(i);
        });
    }
    async _downloadAs(e, t, r) {
        if (!N[e]) throw new Error(`unsupported export fileType - ${e}`);
        if (N[e].singleWorksheet) {
            if (t === void 0) throw new Error(`Must specify worksheetId when exporting as ${e}`);
        } else if (t) throw new Error(`Cannot specify worksheetId when exporting as ${e}`);
        if (e === "html" && (e = "zip"), !this._spreadsheetUrl) throw new Error("Cannot export sheet that is not fully loaded");
        const a = this._spreadsheetUrl.replace("/edit", "/export");
        return (await this.sheetsApi.get(a, {
            baseURL: "",
            params: {
                id: this.spreadsheetId,
                format: e,
                ...t && {
                    gid: t
                }
            },
            responseType: r ? "stream" : "arraybuffer"
        })).data;
    }
    async downloadAsZippedHTML(e) {
        return this._downloadAs("html", void 0, e);
    }
    async downloadAsHTML(e) {
        return this._downloadAs("html", void 0, e);
    }
    async downloadAsXLSX(e = !1) {
        return this._downloadAs("xlsx", void 0, e);
    }
    async downloadAsODS(e = !1) {
        return this._downloadAs("ods", void 0, e);
    }
    async delete() {
        const e = await this.driveApi.delete("");
        return this._deleted = !0, e.data;
    }
    async listPermissions() {
        return (await this.driveApi.request({
            method: "GET",
            url: "/permissions",
            params: {
                fields: "permissions(id,type,emailAddress,domain,role,displayName,photoLink,deleted)"
            }
        })).data.permissions;
    }
    async setPublicAccessLevel(e) {
        const t = await this.listPermissions(), r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$find$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(t, (a)=>a.type === "anyone");
        if (e === !1) {
            if (!r) return;
            await this.driveApi.request({
                method: "DELETE",
                url: `/permissions/${r.id}`
            });
        } else await this.driveApi.request({
            method: "POST",
            url: "/permissions",
            params: {},
            data: {
                role: e || "viewer",
                type: "anyone"
            }
        });
    }
    async share(e, t) {
        let r, a;
        return e.includes("@") ? r = e : a = e, (await this.driveApi.request({
            method: "POST",
            url: "/permissions",
            params: {
                ...t?.emailMessage === !1 && {
                    sendNotificationEmail: !1
                },
                ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$isString$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(t?.emailMessage) && {
                    emailMessage: t?.emailMessage
                },
                ...t?.role === "owner" && {
                    transferOwnership: !0
                }
            },
            data: {
                role: t?.role || "writer",
                ...r && {
                    type: t?.isGroup ? "group" : "user",
                    emailAddress: r
                },
                ...a && {
                    type: "domain",
                    domain: a
                }
            }
        })).data;
    }
    static async createNewSpreadsheetDocument(e, t) {
        if (U(e) === m.API_KEY) throw new Error("Cannot use api key only to create a new spreadsheet - it is only usable for read-only access of public docs");
        const r = await j(e), a = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].request({
            method: "POST",
            url: T,
            paramsSerializer: D,
            ...r,
            data: {
                properties: t
            }
        }), o = new E(a.data.spreadsheetId, e);
        return o._spreadsheetUrl = a.data.spreadsheetUrl, o._rawProperties = a.data.properties, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2f$each$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(a.data.sheets, (h)=>o._updateOrCreateSheet(h)), o;
    }
}
;
}}),

};

//# sourceMappingURL=node_modules_b5ff2c._.js.map